---
layout:     post
title:      "C++基础(三)"
subtitle:   " \"Hello World, Hello C++\""
date:       2016-10-11 12:00:00
author:     "Edtion"
catalog: true
tags:
    - C++语法
---

> 转自：[极客学院C++基础教程][1] 修改部分汉语逻辑（极客学院能翻译成中文并免费开放已经做的很棒了，不要要求太多）

- 插入上两篇留下的疑问：关于命名空间 **std** 可参考 [C++ using namespace std 详解](http://www.kuqin.com/language/20080107/3532.html)

# 存储类型

存储类型定义了变量或函数的作用范围及生命周期。这些说明符也声明了他们的修改方式的类型。有如下几种存储类型：

- auto
- register
- static
- extern
- mutable

### auto 存储类型
**auto** 存储类型是所有局部变量的默认存储类型。

```
    {
       int mount;
       auto int month;
    }
```

上面的例子中定义了两个相同存储类型的变量，auto 仅能运用于函数内的局部变量。

### register 存储类型
**register** 存储类型用于定义存储于寄存器中的变量而不是内存中。这意味着该变量的最大尺寸将是寄存器的大小（通常是一个字），并且不能使用 `'&'` 寻址运算符进行操作（因为它没有内存地址）。

```
    {
       register int  miles;
    }
```

register类型应该仅应用于需要快速访问的变量，比如计数器。需要注意的是，定义 register 类型的变量并不意味着该变量一定就存储在寄存器中，这仅仅意味着需要按照硬件以及具体实现的限制来判定到底是不是存储在寄存器中。

### static 存储类型
**static** 存储类型的变量意味着该变量将会从始至终地存活在程序的整个生命周期内，而不会随着每次访问到它所在的代码块时就建立该变量，离开代码块时就销毁该变量。因此，局部变量静态化可以使他们在函数调用时仍保有其值。

static 修饰符也可以应用于全局变量。 当全局变量使用该修饰符后， 该全局变量就被限制在其声明的文件内。

在 C++中，当 static 应用于类的数据成员时，它所起到的作用是多个该类的成员变量都是指的同一个变量。

```
    #include <iostream>

    // Function declaration
    void func(void);

    static int count = 10; /* Global variable */

    int main()
    {
    	while(count--)
    	{
       	func();
    	}
    	return 0;
    }
    // Function definition
    void func( void )
    {
    	static int i = 5; // local static variable
    	i++;
    	std::cout << "i is " << i ;
    	std::cout << " and count is " << count << std::endl;
    }
```

当上述代码被编译后执行，其结果如下：

```
    i is 6 and count is 9
    i is 7 and count is 8
    i is 8 and count is 7
    i is 9 and count is 6
    i is 10 and count is 5
    i is 11 and count is 4
    i is 12 and count is 3
    i is 13 and count is 2
    i is 14 and count is 1
    i is 15 and count is 0
```

### extern 存储类型
**extern** 存储类型用于使全局变量的引用对所有程序文件可见。如果前面已经定义了一个变量名，那么就不能再使用 extern 来声明同一变量名的变量了。

当你有多个程序文件且需要定义一个可以在其他文件用可以访问到的变量或函数时，就可以在其他文件中使用 **extern** 声明该变量或函数的引用。

extern 修饰符通常被应用于多个文件中需要共享相同的全局变量或函数的情况。一个例子如下：

第一个文件：main.CPP

```
    #include <iostream>

    int count ;
    extern void write_extern();

    int main()
    {
       count = 5;
       write_extern();
    }
```

第二个文件：support.cpp

```
    #include <iostream>

    extern int count;

    void write_extern(void)
    {
       std::cout << "Count is " << count << std::endl;
    }
```

这里的 **extern** 关键字用于声明 count 变量已经在其他文件中定义了。按照下面的方式来编译：

```
    $g++ main.cpp support.cpp -o write
```

这样会生出一个 write 可执行文件，运行它并看他的结果：

```
    $./write
    5
```

### mutable 存储类型
**mutable** 修饰符应用于类对象，将会在后续章节中详细讨论。它允许对象的成员可以覆盖常量。也就是说，mutable 成员可以被 const 成员函数所修改。


# 操作符

操作符就是告诉编译器来执行数学或逻辑运算操作的符号。C++ 有非常丰富的内置操作符。提供如下几类的操作符：

- 数学运算操作符
- 关系运算操作符
- 逻辑运算操作符
- 位运算操作符
- 赋值运算操作符
- 复合运算操作符

下面的章节将一一介绍数学、关系、逻辑、位运算、赋值和其他操作符。

### 数学运算操作符
下面的就是 C++ 语言所支持的数学运算操作符：

假设变量 A 存储 10，变量 B 存储 20，那么：

|运算符	|描述|	例子|
|-|-|-|
|+	|两个运算数相加|	A + B = 30|
|-	|第一个运算数减去第二个运算数|	A - B = -10|
|*	|运算数相乘|	A * B = 200|
|/	|分子除以分母|	B / A = 2|
|%	|模数运算符，整除后的余数|	B % A = 0|
|++	|增量运算符，整数值逐次加1	|A++ = 11|
|-\-	|减量运算符，整数值逐次减1|	A-\- = 9|

### 关系运算符
下面的就是 C++语言所支持的关系运算操作符：

假设变量 A 存储 10，变量 B 存储 20，那么：

|运算符|描述|	例子|
|-|-|-|
|==	|检查两个运算数的值是否相等，如果是，则结果为 true|	A == B 为 false|
|!=|	检查两个运算数的值是否相等，如果不相等，则结果为 true|	A != B 为 true|
|\>	|检查左边运算数是否大于右边运算数，如果是，则结果为 true|	A > B 为 false|
|<	|检查左边运算数是否小于右边运算数，如果是，则结果为 true|	A < B 为 true|
|>=	|检查左边运算数是否大于或者等于右边运算数，如果是，则结果为 true|	A >= B 为 false|
|<=	|检查左边运算数是否小于或者等于运算数，如果是，则结果为 true|	A <= B 为 true|

### 逻辑运算符
下面的就是 C++语言所支持的逻辑运算操作符：

假设变量 A 存储 1，变量 B 存储 0，那么：

|运算符	|描述	|例子|
|&&	|称为逻辑与运算符。如果两个运算数都非零，则结果为 true。|	A && B 为 true|
|\|\|	|称为逻辑或运算符。如果两个运算数中任何一个非零，则结果为 true。|	A \|\| B 为 true|
|!	|称为逻辑非运算符。用于改变运算数的逻辑状态。如果逻辑状态为 true，则通过逻辑非运算符可以使逻辑状态变为 false|	!(A && B) 为 false|

### 位运算符
位操作运算是按位来进行操作的。与、或、非和异或的真值表如下：

|p	|q|	 p&q|	p\|q|	p^q|
|-|-|-|-|-|
|0	|0	|0	|0	|0
|0	|1	|0|	1	|1
|1	|1	|1	|1	|0
|1	|0	|0	|1	|1

假设变量 A 存储 60，变量 B 存储 13，那么：

下面的就是 C++ 语言所支持的位运算操作符：

假设变量 A 存储 60，变量 B 存储 13，那么：

```
A = 0011 1100

B = 0000 1101

A&B = 0000 1100

A|B = 0011 1101

`A^B` = 0011 0001

~A  = 1100 0011
```

|运算符	|描述	|例子|
|-|-|-|
|&	|称为按位与运算符。它对整型参数的每一个二进制位进行布尔与操作。|	A & B = 12 .|
|\|	|称为按位或运算符。它对整型参数的每一个二进制位进行布尔或操作。|	A \| B = 61.|
|^|	称为按位异或运算符。参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。|	(A ^ B) = 49.|
|~	|称为按位非运算符。它是一个单运算符，对运算数的所有二进制位进行取反操作。|	~B = -61 .|
|\<\<|	称为按位左移运算符。它把第一个运算数的所有二进制位向左移动第二个运算数指定的位数，而新的二进制位补0。将一个数向左移动一个二进制位相当于将该数乘以2，向左移动两个二进制位相当于将该数乘以4，以此类推。	|A << 1 =120.|
|\>\>	|称为按位右移运算符。它把第一个运算数的所有二进制位向右移动第二个运算数指定的位数。为了保持运算结果的符号不变，左边二进制位补 0 或 1 取决于原参数的符号位。如果第一个运算数是正的，运算结果最高位补 0；如果第一个运算数是负的，运算结果最高位补 1。|	A >> 1 = 15.|
|\>\>\>	|称为 0 补最高位无符号右移运算符。这个运算符与>>运算符相像，除了位移后左边总是补0.|	A \>\>\> = 15.|

### 赋值运算符
下面的就是C++语言所支持的赋值运算操作符：

|运算符	|描述|	例子|
|-|-|-|
|=|	简单赋值运算符，将右边运算数的值赋给左边运算数|	C = A + B 将 A+B 的值赋给 C|
|+=	|加等赋值运算符，将右边运算符与左边运算符相加并将运算结果赋给左边运算数|	C += A 相当于 C = C + A|
|-=|	减等赋值运算符，将左边运算数减去右边运算数并将运算结果赋给左边运算数|	C -= A 相当于C = C - A|
|\*=	|乘等赋值运算符，将右边运算数乘以左边运算数并将运算结果赋给左边运算数|	C \*= A 相当于C = C * A|
|/=	|除等赋值运算符， 将左边运算数除以右边运算数并将运算结果赋值给左边运算数|	C /= A 相当于 C = C / A|
|%=	|模等赋值运算符，用两个运算数做取模运算并将运算结果赋值给左边运算数|	C %= A 相当于 C = C % A|
|<<=	|左移且赋值运算符	|C <<= 2 相当于 C = C << 2|
|>>=	|右移且赋值运算符	|C >>= 2 相当于 C = C >> 2|
|&=	|位与且赋值运算符	|C &= 2 相当于 C = C & 2|
|^=	|位异或且赋值运算符	|C ^= A 相当于 C = C ^ A|
|\|=	|位或且赋值运算符|	C \|= A 相当于 C = C \| A|

### 复合运算符
下面是 C++ 支持的其他运算符：

|操作符	|描述|
|-|-|
|sizeof|	sizeof 操作符返回变量占用内存的大小。比如，sizeof（a），a 是一个整数时，返回 4|
|条件 ？ X ： Y	|条件操作符：如果条件判断为true，则返回 X，否则返回 Y.|
|,	|逗号操作符：可以使操作顺序执行。整体逗号表达式的值就是逗号最后表达式的返回结果。|
|.(点) 和 ->(箭头)	|成员操作符：用于获取类、结构体或联合体成员的引用。|
|转换	|转换操作符：可以将数值类型转成其他类型，比如，int（2.2000）将返回 2.|
|&	|取地操作符：可以返回一个变量的地址。比如， &a 将会返回变量实际的内存地址。|
|*	|指针操作符：指向一个变量。比如 *var 意味着指向变量 var.|

### C++ 中操作符优先级
运算符优先级确定表达式中项的分组。这会影响如何表达一个表达式。某些操作符比其他有更高的优先级,例如,乘法运算符的优先级高于加法操作符。

比如 x=7+3*2，这里x的值是13而不是20，因为乘法优先级比加法高。所以应该先执行3乘2，然后再加7.

操作符的优先级如下表，上方的优先级比下方高。较高优先级的操作符优先进行计算。

|分类	|操作符	|操作顺序|
|-|-|-|
|后缀运算	|() [] -> . ++ - -	|从左到右|
|一元运算	|+ - ! ~ ++ - - (type)* & sizeof|	从右到左|
|乘法	|* / %	|从左到右|
|加法|	+ -	|从左到右|
|移位|	<< >>	|从左到右|
|相等|	== !=	|从左到右|
|比较	|< <= > >=|	从左到右|
|位与|	&	|从左到右|
|异或	|^	|从左到右|
|位或	|\|	|从左到右|
|逻辑与|	&&	|从左到右|
|\|\|	|逻辑或	|从左到右|
|条件	|?:	|从左到右|
|赋值	|= += -= *= /= %=>>= <<= &= ^= \|=	|从右到左|
|逗号	|，|	从左到右|

# 循环的类型

程序员都会遇到需要多次执行同一代码段的情况。一般情况下，代码会顺序执行：函数中的第一句代码首先会被执行，后面的语句依次执行。

编程语言往往可以提供多种控制结构来实现更复杂的程序执行流程。

循环语句以执行单个语句或一组语句。下面是大部分编程语言中循环语句的一般模式:

![loop_architecture](http://wiki.jikexueyuan.com/project/cplusplus/images/loop_architecture.jpg)

C++ 语言支持下方的循环类型来满足循环的需求。点击链接查看详细情况。

|循环类型	|描述|
|-|-|
|while 循环|	当给定条件为 true 时，执行循环体。在每次执行循环体前都检查条件是否为 true。|
|for 循环	|按照条件执行循环体，可以简化循环体的结构|
|switch 语句	|一个 switch 语句允许一个变量针对多个不同的值分别进行验证是否满足条件。|
|do…while 循环|	与 loop 循环类似，不同的是在循环体后检查条件|
|嵌套循环	|可以嵌套 for 或 loop 循环来多次执行循环体|

### 循环控制语句
循环控制语句可以改变原有循环执行顺序。当循环体执行结束后，其范围内定义的对象都会被销毁。

C++ 语言支持下方的循环控制语句。点击链接查看详细情况。

|循环语句|	描述|
|-|-|
|break	|终止当前 loop 或 switch 代码块，并且跳出后执行后续代码。|
|continue	|跳出当前循环体，检测循环执行条件|
|goto	|跳转到指定的代码标签处，不建议在程序中大量使用该功能。|

### 无穷循环
如果循环条件无法变为 false 的话，那么该训话那就是无穷循环。for 循环就是实现无穷循环。for 循环条件中的三个表达式并不是必须的，所以只要将条件判断语句置空就可以实现无穷循环。

```
    #include <iostream>
    using namespace std;

    int main ()
    {

       for( ; ; )
       {
      printf("This loop will run forever.\n");
       }

       return 0;
    }
```

当条件判断语句置空后，就默认是 true. 程序员也可以保留初始化和递增表达式，但是 C++ 工程师一般都是使用 for（;;）来表达无穷循环。

注意：可以通过 Ctrl + C 的方式来终止无穷循环。



# 决策语句

决策结构需要程序员指定一个或多个可以被程序评估或测试的条件，以及一个语句或者是当条件被确定为真时可以用来执行的语句，和当条件被确定为假时，可以选择用来执行的其他语句。

以下是在大多数编程语言中找到的一个典型的决策结构的通用格式。

![cpp_decision_making](http://wiki.jikexueyuan.com/project/cplusplus/images/cpp_decision_making.jpg)

C++ 编程语言提供以下类型的决策语句。单击以下链接来查看它们的细节。

|语句	|描述|
|if 语句	|一个 if 语句由一个布尔表达式及紧随其后的一个或多个语句组成|
|if…else 语句	|一个 if 语句当执行的布尔表达式为假时，可以在后面伴随着一个可选的 else 语句|
|switch 语句|	一个 switch 语句允许一个变量针对多个不同的值分别进行验证是否满足条件。|
|嵌套的 if 语句	|你可以使一个if或者 else if 语句嵌套在另一个 if 或 else if 语句中。|
|嵌套的 switch 语句|	你可以一个 switch 语句中嵌套使用另一个 switch 语句中。|

### ？：运算符
我们在前一章中有可以用来替换 **if...else** 语句的覆盖条件语句？：。它具有以下基本形式：

```
    Exp1 ? Exp2 : Exp3;
```
其中 Exp1 , Exp2 和 Exp3 是表达式。注意冒号的使用和它的位置。

？ 表达式值的计算方式为：首先计算 Exp1 的值。如果 Exp1 为真，则计算 Exp2 的值作为整个 ？ 表达式的值，如果 Exp1 为假，则计算 Exp3 的值，并且将其作为这个表达式的值。

















